# iOS_Interview_Questions

제르시 면접 질문 답변 문서화

[GitHub - JeaSungLEE/iOSInterviewquestions: 👨🏻‍💻👩🏻‍💻iOS 면접에 나올 질문들 총 정리](https://github.com/JeaSungLEE/iOSInterviewquestions)

---

### 개요

iOS 면접 준비와 학습을 위해 각 질문의 답을 고민하고 이해해보자.

### 이용방법

- **문서 형식**
    1. 제목1 수준 문단(# 기호)은 토글(> 기호)과 “Level n” 문자열 형식으로 예약되어 있습니다.
    2. 제목2 수준 문단(## 기호)은 각 레벨 별 대표 질문에 색상을 입힌(Cmd + Shift + H) 형식으로 예약되어 있습니다.
    3. 제목3 수준 문단(### 기호)은 각 레벨 별 대표 질문의 하위 질문(또는 꼬리 질문)으로 예약되어 있습니다.
    4. 이외 각 질문 별 답변에서 중요한 키워드나 제목은 볼드(**…**)처리하고 내용을 자유롭게 작성합니다.
    5. 각 내용 별로 구분선(./divide)을 사용해 가독성을 올리고 서식 통일 해주시면 됩니다.

---

# Level 0

## 컴퓨터 구조와 관련하여 CPU, RAM, 저장장치의 역할과 상호작용에 대해 설명하라.

컴퓨터 구조에서 CPU, RAM, 저장장치는 각자의 역할을 수행하며 컴퓨터 동작을 위해 상호작용 한다. 이 컴퓨터 요소의 역할에 대하여 비유를 통해 설명하기 위해 각 요소를 의인화, 사물화 하여 어떠한 작업실(사무실)에 있다고 가정한다.

**CPU**

중앙처리장치(Central Processing Unit, 이하 CPU)는 컴퓨터 시스템을 통제하고 프로그램의 연산을 실행, 처리하는 요소이다.

CPU는 작업실에 위치한 작업자(책상 주인)이다. 이 작업자는 책상에 앉아 어떠한 일을 처리할 수 있다. 그렇게 ‘처리’함으로써 작업실의 사무는 다른 활동으로 이어지거나 하여 운영된다. 작업자는 일 처리를 위해 자신이 사용할 도구(연필, 자, 칼, 가위 등)를 필요로 한다. 이 도구는 작업자가 곧바로 집어들 수 있는 위치에 있는 것이 일 처리의 측면에서 빠르고 편할 것이다. 따라서 작업자는 자신과 가까워 손을 곧장 옮길 수 있는 곳에 도구를 두고 레지스터, 캐시 메모리라는 이름으로 부른다. 작업자가 자주 사용하는 도구는 이곳에 놓여져 있을 확률이 크다.

**RAM**

임의접근메모리(Random Access Memory, 이하 RAM)은 컴퓨터의 전원 공급 및 동작 시작부터 종료까지 어떠한 데이터나 프로세스를 ‘기억’하기 위해 존재하는 요소이다.

RAM은 작업실에 위치한 작업자가 일할 수 있는 책상이다. 이 책상이 넓으면 다양한 물건들을 올려 작업할 수 있고, 반대로 좁다면 상대적으로 적은 물건들을 올려 수시로 정리하면서 작업해야 한다. 작업자가 출근하면 그 날 주어진 업무를 처리하기 위해 평소에 애용하던 도구들을 꺼내오기 시작한다. 만약 연필이 필요해지면 연필을 가져온다. 혹은 칼이 필요해지면 칼을 가져와 책상에 올려 둔다. 일을 처리하는 곳은 책상이므로 도구를 책상에 올려놓아야 일할 수 있다.

**저장장치**

저장장치는 사물함(Cabinet)과 같다. 평소에 사용할 도구들은 저장장치인 사물함에 보관되어 있다. 작업자가 일을 하고있지 않는 시간에는 책상에 각종 도구들을 어지러이 올려 둘 수 없기에 사물함에 보관한다고 생각하자. 그 면적과 부피가 확실히 책상보다는 크고 넓기 때문에 많은 도구들을 보관할 수 있다. 단, 도구를 써야 할 때, 의자에서 일어나 사물함을 열어 도구가 있는지 차례대로 뒤적거려야 하는 번거로움이 있다. 또한 새로운 도구를 가져왔는데 책상에 올려둘 곳이 없다면, 다시 사물함에 도구를 갖다 놓아 정리를 해야한다.

CPU, RAM, 저장장치는 사무실의 업무가 정상적으로 진행되고 회사가 잘 운영되기 위해서 서로 협력한다. 또 운영체제 등의 관리자급 직원에게 관리받는 요소이기도 하다.

---

### 캐시 메모리의 개념과 종류, 역할에 대해 설명하라.

**캐시 메모리**는 CPU가 메인메모리에 접근해서 데이터를 가져와 연산 처리하는데 매우 느리다는 사실을 해소하고자 둘 사이에 추가로 끼운 메모리이다. CPU의 연산 속도에 비해서는 느리지만 메인메모리에 접근하여 데이터를 가져오는 것보다 캐시 메모리에 접근하여 데이터를 가져오는 것이 더 빠르기 때문에 시스템 성능 향상에 도움이 된다. 캐시 메모리는 휘발성 메모리인 RAM의 일종이다. 단, 메인메모리 역시 RAM이지만 그보다 접근 속도가 상대적으로 빠르기에 메인메모리와 구분된다.

자주 사용하는 데이터라면 매번 메인메모리에 접근해 가져오는 것보다 상대적으로 가깝고, 빨라 접근하기 용이한 곳에 저장해두어 사용하는 것이 성능 측면에서 유리할 것이다. 이렇게 자주 사용되는 데이터를 미리 보관해두는 것을 **캐싱**이라고 하며, 이 캐싱 기법을 적용한 메모리가 캐시 메모리인 것이다. 생각해보면 캐싱은 우리 삶에 다양한 형태로 활용되고 있음을 알 수 있는데, 캐시 메모리도 그 중 하나의 예시이고, 네트워크나 다른 분야에서도 이미 적용되어 있다.

**캐시 메모리는 또다시 위치, 속도, 크기, 용도 등에 따라 3~4개의 수준으로 분류할 수 있다.**

- L1 Cache: 레벨1 캐시는 일반적으로 프로세서 자체에 내장되어 있다. 최근에 사용된 명령어나 데이터를 저장한다. 최근에 사용되었다는 것은 다시 불려와 사용될 일이 잦다는 원리에 의거한 것으로, 이는 지역성과 관련이 깊다. 다른 유형의 저장장치에 비해 속도가 매우 빠르다는 특징이 있다.
- L2 Cache: 레벨2 캐시는 레벨1 캐시와 같이 프로세서 자체에 내장되어 있다. 대부분 레벨1 캐시보다 크기가 크지만 속도는 느리다.
- L3 Cache: 레벨3 캐시는 CPU 코어에 내장된 윗 수준 캐시와 달리 전체 프로세스가 접근할 수 있는 공유 메모리 풀 형태로 작동한다. 마찬가지로 윗 수준 캐시보다 크기가 커지고 속도는 느려진다.
- L4 Cache: 레벨4 캐시는 레벨3 캐시 이후로 캐시 메모리를 추가한 형태이다.

캐시 메모리는 자주 접근하는 특정 데이터를 CPU 가까이 보관해두고 메인메모리를 검색하는 것보다 빠르게 이용하게 만듦으로써 그렇게 절약한 대기시간을 다른 작업에 투자해 전체적인 성능 향상을 꾀할 수 있도록 해준다. 단, 캐시 메모리에 원하는 데이터가 없는 상황도 분명히 생긴다. 이를 **캐시 미스**라고 한다. 이런 경우에는 곧바로 메인메모리에 접근해 데이터를 가져오는 것보다, 캐시 메모리를 검색한 뒤 데이터가 없는 것을 확인하고 메인메모리로 이동하는 것이므로 오히려 데이터 검색이 느려지는 효과가 발생하기도 한다. 따라서 캐시 미스 상황을 최대한 줄일 수 있는 방향을 고민해보는 것이 바람직하다.

정리하자면, 캐시 메모리는 대기시간 절약, 프로세스 처리량 증가, 전력 소비 감소, 안정성 향상 등 여러가지 이점을 제공하는 컴퓨팅 자원이다.

---

### CPU 아키텍처의 종류와 특징에 대해 설명하라.

CPU 아키텍처는 CPU가 명령어를 해석하고 실행하는 방식을 정의한다. 가장 널리 알려진 CPU 아키텍처는 x86과 ARM이 있다. 이렇게 CPU 아키텍처의 종류가 나눠지는 이유는, CPU가 해석할 명령어를 나열하고 집합한 형태가 다르기 때문이다. **CISC**(Complex Instruction Set Computing) 방식은 다양하고 복잡한 명령어 집합을 사용하여 한 명령어를 사용해 여러 명령어를 실행할 수 있다. 따라서 활용도는 높지만 실행 속도가 느릴 수 있다. **RISC**(Reduced Instruction Set Computing) 방식은 간단한 명령어 집합을 사용하여 각 명령어를 실행할 수 있다. 따라서 활용 시 명령어 조합이 길어지지만 각 명령어는 단순하고 빠르게 실행된다.

**x86**

x86 아키텍처는 Intel이 개발한 아키텍처이며, 16비트 프로세서로 시작해 32비트(x86), 64비트(x64) 버전으로 확장되었다. 이 아키텍처는 주로 개인용 컴퓨터나 서버, 워크스테이션 등에서 사용된다. CISC 방식의 아키텍처이기에 이 방식이 가진 다양한 명령어 집합은 여러 소프트웨어와 호환할 수 있다. 또한 고성능 컴퓨팅 작업에 사용되기 좋다.

**ARM**

ARM 아키텍처는 ARM 홀딩스에서 개발한 아키텍처로 저전력 소비를 중점으로 설계된 만큼, 주로 스마트폰, 태블릿, 임베디드 시스템 등에서 사용된다. RISC 방식의 아키텍처이기에 단순한 명령어를 사용하며 특히 모바일 장치와 같이 배터리 수명이 중요한 디바이스에 적합하다.

---

### iOS 기기에서 사용되는 AP의 특징과 역할에 대해 설명하라.

**AP**(Application Processor)는 디바이스의 중심적인 역할을 담당하는 핵심 요소이다. 시스템을 구성하는 여러 요소가 하나의 칩에 들어있다고 하여 **SoC**(System on Chip)으로 불리며, CPU, GPU, NPU, DSP 등 다양한 기능을 하나의 칩에 통합한 형태이다. 작게 집적화한 소형 칩인 AP는 그 용도에 맞게 모바일 기기처럼 작은 디바이스에서 사용되며 성능, 전력 소모, 활용성 등 디바이스 설계에 직접적인 영향을 미친다.

애플의 AP는 다양한 종류가 있다. 그 중에서도 iOS 기기에서 사용되는 AP는 A시리즈라고 불리운다. A시리즈 AP는 내장된 CPU, GPU, NPU, 각종 메모리 등의 도움을 받아 iOS 기기의 데이터 처리, 그래픽 처리, 인공지능 및 머신러닝, 통신 등의 역할을 수행한다. ARM 아키텍처로 설계되어 있기에 iOS 기기의 성능을 높이 끌어 올리면서도 배터리 수명을 고려해 저전력 효율화를 꾀한다. 또 지문, 얼굴 인식 등 개인정보 데이터를 안전하게 처리 한다던가, 최상의 사용자 경험을 위해 강력하고 효율적인 기능을 가진 AP로 설계되어 있다.

---

## 운영체제의 역할과 iOS에서의 운영체제 구조에 대해 설명하라.

**운영체제**는 시스템 사이드(하드웨어와 가까운)의 특별한 소프트웨어이다. 운영체제는 다른 사용자 소프트웨어가 하드웨어를 이용해 원활하게 동작하기 위하여 존재하는 중간 관리자이다. 하드웨어 및 시스템 자원을 관리하고, 응용 소프트웨어를 실행하기 위하여 추상화된 하드웨어 인터페이스를 제공한다. 대표적으로 입출력, 메모리 할당과 같은 하드웨어 기능을 제공하고, 멀티태스킹을 지원하는 경우 스케줄링을 비롯한 프로세스 관리 등을 운영체제가 담당한다.

**iOS**는 macOS를 기반으로 만들어져 iPhone과 같은 모바일 장치를 사용하기 위해 필요한 운영체제이다. macOS와 마찬가지로 Darwin Foundation을 기반으로 한다. iOS는 네 개의 추상화 계층으로 구성되어 있다. 운영체제의 구조를 추상화하여 계층 별로 구분 지으면 기기를 이용하거나 애플리케이션을 개발할 때 필요한 기술을 쉽게 접근하여 이용할 수 있다.

**iOS 추상화 구조**

1. **Core OS**
    
    하드웨어와 상호작용하는, 가장 시스템 사이드에 위치한 계층이다. 이 계층은 보안, 통신, 메모리 관리, 파일 시스템 관리 등의 기본적인 기능을 포함한다.
    
    Accelerate, Directory Service, Disk Arbitration, OpenCL, System Configuration
    
2. **Core Service**
    
    Core OS 레이어 위에 위치해 있으며 보다 고수준의 API를 통해 데이터 관리, 네트워킹, 위치 서비스 제공 등의 기능을 제공한다.
    
    Foundation, Address Book, Core Data, Core Foundation, Social, Quick Look, Security, WebKit
    
3. **Media**
    
    Core Service 레이어 위에 위치해 있으며 오디오, 비디오, 그래픽 처리와 같은 멀티미디어 컨텐츠를 처리하는 기능을 제공한다.
    
    AVFoundation, Core Animation, Core Audio, Core Image, Core Text, OpenAL, OpenGL, Quartz
    
4. **Cocoa Touch**
    
    사용자 소프트웨어 밑의 가장 상위에 있는 계층이며 사용자 인터페이스를 구성하고 멀티터치, 제스처 인식, 가속도계, 위치 서비스 등의 기능을 포함한다. UI Component를 관리하고 이벤트 처리를 담당한다. 또한, 애플리케이션의 생명주기 관리, 알림, 네트워킹 등 하위 계층의 기능을 보다 고수준의 API를 통해 이용할 수 있게 한다.
    
    AppKit, UIKit, SwiftUI
    

---

### 프로세스와 스레드의 차이점, iOS에서의 프로세스와 스레드 관리 방법에 대해 설명하라.

**프로세스**는 정적인 코드 덩어리인 ‘프로그램’이 운영체제로부터 자원을 할당받아 동적으로 활성화된 작업의 단위이다. **스레드**는 프로세스가 할당받은 자원을 이용해 동작하는 중 만들어진 동작 흐름의 단위이다.

**메모리 사용과 관련한 프로세스와 스레드의 비교**

- **프로세스**
    
    프로그램 활성화와 작업 수행을 위해 운영체제로부터 할당받는 자원 중, 대표적인 것이 바로 메모리이다. 프로그램 활성화를 통해 프로세스가 탄생한다는 것은 정적인 코드 덩어리가 메모리에 채워지게 된다는 것이고, 이 메모리는 보통 코드, 데이터, 스택, 힙 영역으로 구분되어 용도에 맞게 할당 및 해제된다. 할당받은 메모리 영역은 프로세스 간 독립적(고립적)으로 사용되기 때문에 프로세스 간 자원을 공유하기 위해서는 운영체제의 도움을 받아 IPC(Inter-Process Communication), LPC(Local inter-Process Communication), 메세지 버스, 공유 메모리 사용 방식을 사용해야 한다. 단, 이 경우 단순히 CPU 레지스터 교체 뿐 아니라 RAM과 CPU 간의 캐시 메모리까지 초기화도기 때문에 오버헤드가 크다는 단점이 있다. 따라서 현대 컴퓨터 운영체제에서는 멀티 프로세싱을 지원하고 있지만 멀티 스레딩을 기본적으로 사용한다.
    
- **스레드**
    
    프로세스는 반드시 하나 이상의 스레드를 갖게 되는데 대표되는 하나의 스레드를 메인 스레드라고 부른다. 스레드는 한 프로세스의 동작 흐름에서 파생한 여러 흐름의 단위이기 때문에, 역시 운영체제로부터 얻은 자원을 사용할 수 있다. 여러 스레드 간에는 한 프로세스가 할당받은 자원을 공유하면서 프로세스 실행 흐름의 일부가 되기 때문에 동시 작업도 가능하다. 이때 프로세스에게 주어진 네 가지 메모리 영역 중, 스레드는 스택 영역에 해당하는 메모리만 복사해 독립적으로 유지하고, 나머지 영역은 다른 스레드들과 공유한다. 독립적인 스택 영역을 가지고 있다는 것은 함수 호출 및 복귀가 가능하다는 것이기에 스레드는 독립적인 실행 흐름의 단위로서 존재할 수 있게 된다. 또 다른 메모리 영역에 대해서는 공유하면서 읽고 쓰기가 가능하다. (반면 프로세스는 별도의 통신 수단없이 다른 프로세스의 메모리에 직접 접근할 수 없다. 이 경우 운영체제는 잘못된 메모리 접근으로 인해 Abort 콜을 내릴 것이다.)
    

**동시성 처리와 관련한 프로세스와 스레드의 비교**

- **프로세스**
    
    프로세스가 생성되면 메모리에 해당 프로세스의 PCB(Process Control Block)가 함께 생성되고 종료시 삭제된다. 운영체제는 PCB에 담긴 프로세스의 고유 정보를 통해 프로세스의 생명주기를 관리하고 다른 프로세스와의 동기화를 제어할 수 있다. CPU가 다중 처리를 수행할 때 PCB에 담긴 프로세스의 상태를 확인하고 상태 변경 및 Context Switching 등, 동시성 제어를 수행한다. 프로세스는 운영체제로부터 이러한 제어를 받으며 생성, 준비, 실행, 대기, 종료의 프로세스 상태 전이가 이루어지며 동작한다.
    
- **스레드**
    
    스레드가 생성되면 메모리에 해당 스레드의 TCB(Thread Control Block)이 함께 생성되고 종료 시 삭제된다. 더욱 정확히는 운영체제가 PCB 안에 TCB를 통해 스레드의 고유 정보를 저장하고 생명주기 관리에 활용한다. 프로세스와 마찬가지로 운영체제는 TCB를 통해 스레드의 상태를 확인하고 상태 변경 및 Context Switching 등의 동시성 제어를 수행하는데, TCB는 스택 및 간단한 레지스터 포인터 정보만을 저장하기 때문에 PCB의 Context Switching 보다는 가볍고 빠르다. 스레드는 운영체제로부터 이러한 제어를 받으며 생성, 준비, 대기, 종료의 스레드 상태 전이가 이루어지며 동작한다.
    

iOS는 멀티태스킹 환경을 지원한다. iOS에서 모든 애플리케이션은 각각 별도의 프로세스로 실행된다. iOS는 앱 간에 엄격한 샌드박스 환경을 적용하여 각 앱의 프로세스가 다른 앱의 데이터나 자원에 접근하지 못하게 한다. 프로세스의 경우, 애플리케이션 프로세스의 생명주기는 iOS에서 자동으로 관리되고 처리되며, 개발자는 UIKit이나 SwiftUI와 같은 프레임워크의 생명주기 이벤트를 통해 이를 관찰하고 적절히 반응하면 된다.

스레드의 경우, 태스크 기반 병렬 프로그래밍 지원 프레임워크인 GCD(Grand Central Dispatch)를 이용해 시스템이 스레드를 관리할 수 있도록 개발자가 코드 상에서 명시해 줄 수 있다. 또한 C 기반으로 제작된 GCD를 보다 고수준의 인터페이스로 제공하는 Operation 및 OperationQueue를 이용할 수도 있다.

---

### 메모리 관리 기법 중 iOS에서 사용되는 방식과 그 특징에 대해 설명하라.

iOS에서 메모리를 관리하는 기술에는 **MRC**와 **ARC**가 있다.

- **MRC(Manual Reference Counting)**
    
    MRC는 개발자가 직접 참조 횟수를 관리하는 방식이다. 객체 생성 시에는 자동으로 참조 횟수를 하나 올려주지만 그 이후부터는 새로이 참조할 때(retain), 참조하지 않을 때(release)를 수동으로 관리하며, 시스템은 참조 횟수가 0이 될 때 메모리에서 해제(dealloc)한다. 참조 횟수를 직접 관리하여 메모리 할당 및 해제를 통제할 수 있다는 것은 장점이지만, 올바른 참조 카운팅을 실시하지 않으면 메모리 누수 등의 문제가 생긴다는 것과 개발의 복잡성이 증가한다는 단점이 있다.
    
- **ARC(Automatic Reference Counting)**
    
    ARC는 컴파일러가 자동으로 참조 횟수를 관리해주는 방식이다. 객체 생성 및 참조 시에는 참조 횟수를 증가, 참조하지 않게되면 참조 횟수가 감소하는 것으로 메모리 할당, 해제가 이루어진다. ARC 시스템은 컴파일 시점에서 retain, release, autorelease 등의 참조 카운팅 코드를 삽입해준다. 보통 메모리 관리를 직접 하지 않아 편리하지만 순환 참조 등의 일부 상황에서는 메모리 누수 등의 문제가 발생하지 않도록 신경써 주어야 한다.
    

현재는 주로 Swift를 사용해 개발하는 만큼 ARC를 통해 메모리를 관리하는 것이 일반적이다. 런타임에 객체들의 참조 상태를 주기적으로 검사하여 메모리를 관리하는 GC(Garbage Collector)와 달리 ARC는 컴파일 시점에 코드 상에 드러난 메모리 참조 상태를 확인해 적절히 코드를 삽입하는 것으로 메모리를 관리한다는 차이가 있다.

---

### iOS의 샌드박스(Sandbox) 개념과 역할, 앱 간 데이터 공유 방법에 대해 설명하라.

샌드박스는 앱의 데이터 접근과 각종 권한에 대한 보안을 강화하기 위한 시스템이다. 유효한 권한 상에서 앱 데이터, 자원을 요청할 수 있고 그 외에는 접근을 제한하여 시스템 자원과 사용자 데이터를 보호한다. 샌드박스는 마치 울타리처럼 앱이 사용하는 데이터의 접근 범위와 디바이스 사용 권한을 감싸, 앱을 격리된 환경에서 실행시켜서 앱이 울타리를 벗어난 다른 부분에 임의로 접근하는 것을 제한하고 허가되지 않은 권한을 남용하는 것을 막는다. 이러한 샌드박스 구조는 기본적으로 앱 마다 별도의 파일로 관리되어 공유되지 않도록 하고, 외부의 공격으로부터 앱이 손상된 경우, 이 손상으로 인한 피해를 최소화하는 것을 목적으로 한다.

앱을 설치하면 해당 앱의 샌드박스 디렉토리가 생성되는데, 최상위의 샌드박스 디렉토리를 홈 디렉토리라고 부른다. 홈 디렉토리는 역할따라 여러 하위 디렉토리를 갖는다. 이렇게 디렉토리를 통해 앱을 구조화 하

**Bundle Container**

번들 컨테이너는 Bundle이 담긴 디렉토리이다. 실행파일, Property List, 이미지나 사운드 같은 리소스 파일 등이 `~.app` 확장자를 가진 번들로서 정리되어 있다. 번들 컨테이너에 담긴 데이터는 읽기 전용이며, 쓰기 작업이 필요한 경우에는 데이터 컨테이너로 옮겨서 작업한다. 이 영역은 설치 시점에 서명되어, 만약 쓰기 작업이 이루어질 경우 서명이 변경되게 되고 앱을 실행할 수 없게 된다. 또 iTunes, iCloud에 의해 백업되지 않는다는 특징도 있다.

**Data Container**

데이터 컨테이너는 앱에서 사용되는 다양한 데이터를 다루며, 다시 용도 별로 Documents, Library, Temp, System Data와 같은 하위 디렉토리로 나누어 보관한다.

- **Documents**
    
    사용자가 앱에서 생성한 컨텐츠를 저장하는데 사용되는 공간이다. 파일 공유를 통해 다른 사용자에게 공유할 수 있는 곳 이기에, 노출하고자 하는 파일만 포함해야 한다. 문서 디렉토리의 내용은 백업이 이루어진다.
    
- **Inbox**
    
    외부 요청에 의해 파일에 접근해야할 경우에 사용되는 공간이다.
    
- **Library**
    
    사용자의 데이터 파일이 아닌 다른 모든 파일의 최상위 디렉토리이다. Cache, Preferences, Database 등이 이곳에 저장된다. 특히 Application Support 디렉토리는 앱이 동작하기 위해 생성된 지원 파일이 포함되지만 사용자에게 노출시킬 필요가 없는(또는 숨겨야 하는) 파일이 포함되는 곳이다. 또, Caches 디렉토리는 임시 디렉토리와 달리, 오래 재사용 될 수 있는 데이터를 저장하는 공간이며 캐싱을 통한 성능 향상을 기대하는 경우에 사용되는 공간이다. iOS가 공간 최적화를 위해 Caches 디렉토리의 파일을 제거할 수 있으므로 앱은 필요에 따라 다시 만들거나 다운로드할 수 있어야 한다.
    
- **Temp**
    
    일시적으로 생성되어 오래 재사용 할 필요가 없는 데이터를 저장하는 공간이다. iOS는 앱이 실행 중이지 않을 경우, 공간 최적화를 위해 임시 디렉토리의 파일을 제거하기 때문에 앱이 종료되면 이 공간에 있던 데이터들을 찾지 못할 수도 있다.
    

기본적으로 앱 간의 약속되지 않은 데이터 접근은 금지되어 있기 때문에, iOS에서는 샌드박스 환경 내에서도 앱 간에 안전하게 데이터를 공유할 수 있는 다양한 방법을 제공한다.

1. **URL Schemes**
    
    특정 앱을 실행하거나, 앱 간에 데이터를 전송하기 위해 사용된다. 앱은 특정 URL 스키마를 등록하고, 다른 앱이 이 URL을 호출함으로써 데이터를 교환할 수 있다.
    
2. **App Groups**
    
    여러 앱이 같은 데이터 컨테이너에 접근할 수 있도록 하는 방법이다. 이를 통해 동일한 개발자의 앱들이 데이터를 공유할 수 있다.
    
3. **App Extensions**
    
    앱 확장을 통해 위젯을 다루는 투데이 화면에서 직접 앱의 정보를 받아 보여주는 등, 다른 앱의 데이터를 공유할 수 있다.
    

이 외에도 앱 간에 데이터를 공유하는 많은 방법이 있다. iOS의 샌드박스 개념과 앱 간 데이터 공유 방법은 사용자의 데이터 보호와 시스템 보안을 위해 중요한 역할을 한다는 점에서 중요하다.

---

## iOS에서의 메모리 구조와 관리 방식에 대해 자세히 설명하라.

프로그램이 실행 되려면 메모리 공간을 확보하고 적재해 활성화 시켜야 한다. 운영체제는 용도에 따라 네 가지의 세그멘테이션으로 나누어 프로그램이 메모리에 올라올 수 있도록 한다. 네 가지의 세그멘테이션은 바로 **코드 영역**, **데이터 영역**, **힙 영역**, **스택 영역**이며, 이들이 메모리 구조를 구성한다.

---

### iOS 앱의 메모리 구조와 각 영역의 특징에 대해 설명하라.

각 영역은 용도에 따라 논리적으로 나뉜 세그멘테이션이다.

- **코드 영역**
    
    앱 코드가 번역되어 저장되는 공간으로, 읽기 전용으로 설명되어 있어서 프로그램 동작 도중에 코드가 변경되지 않도록 보호한다. 컴파일 시점에 공간의 크기가 결정된다. 앱의 시작과 종료에 맞추어 생명주기를 함께한다.
    
- **데이터 영역**
    
    전역 변수와 `static` 변수처럼 앱 동작 중에 고정된 크기를 가지며 앱과 동일한 생명주기를 갖는 데이터가 저장되는 공간이다. 컴파일 시점에 공간의 크기가 결정된다.
    
- **힙 영역**
    
    동적으로 메모리를 할당해야할 때 사용하는 공간이다. 앱의 시작과 종료와 관계없이 앱이 동작하면서 할당 되기에 런타임에 공간의 크기를 알 수 있고 가변적이다. 때문에 메모리 할당, 해제를 주의하며 관리해야 한다. 클래스 인스턴스, 클로저 같은 참조 타입이 힙 영역을 사용한다. 또 Array 같은 일부 값 타입도 효율 측면에서 힙 영역을 사용한다.
    
- **스택 영역**
    
    지역 변수, 함수의 매개변수, 함수 실행 중의 값 같은 일시적인 값이 담기는 공간이다. 따라서 함수의 호출과 반환이 곧 생명주기가 된다. 컴파일 시점에 공간의 크기가 결정된다.
    

---

### 힙 영역에서 객체가 어떻게 할당되고 관리 되는지 설명하라.

iOS 프로그래밍 관점에서 힙 영역의 객체 할당 및 관리는 Objective-C 또는 Swift와 같은 프로그래밍 언어에 따라 다르게 이루어진다. Swift라는 가정에서, iOS는 주로 ARC를 사용해 메모리 관리를 자동화한다.

**객체 할당**

- 객체 생성
    
    iOS 앱에서 객체는 보통 클래스의 인스턴스를 생성하는 것으로 힙 영역에 할당된다. 클래스의 멤버는 크기에 따라 주어진 힙 영역을 각자 나누어 사용한다.
    
- ARC
    
    ARC는 객체의 참조 횟수를 추적하여, 참조 횟수가 0일 때 자동으로 메모리에서 해제한다. 이는 개발자가 직접 메모리를 관리할 필요가 없게 해주어 메모리 관리를 단순화시킨다. 또는, 일부 상황에서 메모리 해제를 직접 명시하는 것도 가능하다.
    

**객체 사용**

힙에 할당된 객체는 프로그램 내에서 접근하고 사용될 수 있으며, 해당 객체의 생명주기 동안에만 존재한다. 그러한 생명주기는 ARC가 확인하는 참조 횟수로 결정된다.

**객체 해제**

- ARC에 의한 자동 해제
    
    ARC는 객체의 참조 횟수가 0이 되면, 즉 해당 객체를 참조하는 변수나 상수가 더 이상 존재하지 않을 때, 객체를 메모리에서 해제한다. 객체를 더이상 사용하지 않을 때 `nil` 값을 할당하거나, `deinit`을 호출하는 등, 참조 제거 행동을 실시할 수도 있다.
    
- Memory Leak
    
    ARC는 대부분의 메모리 관리 작업을 자동으로 처리하지만, 순환 참조와 같은 상황에서는 메모리 누수가 발생할 수 있다. 따라서 `weak`, `unowned` 와 같은 키워드를 사용해 순환 참조를 방지하는 것이 중요하다.
    

---

### 스택 영역에서 함수 호출과 지역 변수의 메모리 할당 및 해제 과정을 설명하라.

스택 영역은 프로그램 동작 중 임시적으로 데이터를 저장하는 공간이다. 함수의 호출과 지역 변수의 메모리 할당 및 해제 과정은 스택 영역을 사용해 이루어진다.

1. **함수 호출**
    
    함수가 호출되면 호출된 함수의 실행을 위한 메모리 공간이 스택 영역에 할당되며, 이곳을 **스택 프레임**이라고 한다. 함수의 매개변수, 반환 주소, 지역 변수 값 등을 저장한다. 반환 주소란 함수 종료 후 되돌아갈 위치를 가리키며, 보통 함수를 호출한 곳이 된다.
    
2. **지역 변수 메모리 할당**
    
    함수 호출 후 함수 내에서 선언된 지역 변수를 위해 스택 영역의 메모리 공간을 할당한다. 이 메모리 공간은 함수의 생명주기와 함께 유지되며, 함수 스코프 내에서 접근할 수 있다.
    
3. **함수 동작**
    
    함수 요소의 메모리 할당이 모두 완료되면 함수가 실행된다. 다른 함수가 호출될 경우, 마찬가지로 스택 프레임을 생성, 과정을 반복한다.
    
4. **지역 변수 메모리 해제**
    
    함수 종료에 임박하고 함수 생명주기와 함께하던 지역 변수의 메모리 공간은 해제된다.
    
5. **함수 반환**
    
    저장되어 있던 반환 주소를 참고하여 함수를 호출한 곳으로 제어 흐름을 되돌린다.
    

스택 영역은 기본적으로 스택 자료구조의 FIFO 성격이 나타나기 때문에, 함수의 함수 호출로 인해 스택 프레임이 쌓이게 되고 함수의 종료로 인해 스택 프레임 생성의 역순으로 메모리 해제가 이루어진다.

---

## 네트워크 프로토콜 스택과 iOS에서의 네트워크 통신 방식에 대해 설명하라.

네트워크 프로토콜은 네트워크 통신을 가능하게 하는 각종 약속의 기술이다. 그리고 이러한 프로토콜은 그 사용 범위와 용도에 따라 계층 별로 구분되는데, 이 모습이 마치 스택처럼 쌓여있기에 **네트워크 프로토콜 스택**이라 부른다. 가장 널리 알려진 모델은 OSI(Open System Interconnection) 7 Layers가 있다. 또, 네트워크 프로토콜 중 TCP와 IP를 중심으로 단순화한 모델인 TCP/IP 4 Layers도 있다.

**OSI 7 Layers**

OSI 7 Layer는 시스템 간의 통신을 물리적, 데이터 링크, 네트워크, 전송, 세션, 표현, 응용의 7개 추상화 계층으로 나누어 표현한 ISO(국제 표준화 기구)의 참조 모델이다. 각 계층은 그 상위의 계층에 기능 클래스를 제공하고 하위의 계층의 도움을 받아 제공된다. 쉽게 말해 A → B → C 구조로 이루어진 계층에 대하여 B 계층은 A 계층의 기능을 사용해 구현되어 C 계층을 구현하는 기반이 된다는 것이다.

1. 물리 계층
    
    기계에 가까운 전송 기술을 다룬다. 케이블, 카드 등 물리적인 매체를 통해 데이터를 전송한다.
    
2. 데이터 링크 계층
    
    동일한 네트워크 기기 간의 데이터 전송을 담당한다. 데이터를 프레임이라는 단위로 하고, MAC 주소를 사용하여 데이터를 전송한다.
    
3. 네트워크 계층
    
    서로 다른 네트워크 기기 간의 데이터 전송을 담당한다. IP 주소를 사용하여 최적의 경로를 결정해 데이터를 전송한다.
    
4. 전송 계층
    
    두 장치 간의 연결을 관리하고, 데이터의 전송을 담당한다. 주로 TCP 또는 UDP 라는 프로토콜을 사용한다.
    
5. 세션 계층
    
    통신 세션을 관리하며, 통신의 시작과 종료를 담당한다.
    
6. 표현 계층
    
    데이터의 형식을 정의하고, 암호화 및 압축 등의 작업을 담당한다.
    
7. 응용 계층
    
    최종 사용자와 직접 상호작용하는 응용 프로그램 수준에 가깝다. HTTP, FTP 등의 프로토콜을 사용한다.
    

**URLSession, WebSocket**

작성 예정…

---

# Level 1
