# iOS_Interview_Questions
제르시 면접 질문 답변 문서화

[GitHub - JeaSungLEE/iOSInterviewquestions: 👨🏻‍💻👩🏻‍💻iOS 면접에 나올 질문들 총 정리](https://github.com/JeaSungLEE/iOSInterviewquestions)

---

### 개요

iOS 면접 준비와 학습을 위해 각 질문의 답을 고민하고 이해해보자.

### 이용방법

* **문서 형식**
    1. 제목1 수준 문단(# 기호)은 토글(> 기호)과 “Level n” 문자열 형식으로 예약되어 있습니다.
    2. 제목2 수준 문단(## 기호)은 각 레벨 별 대표 질문에 색상을 입힌(Cmd + Shift + H) 형식으로 예약되어 있습니다.
    3. 제목3 수준 문단(### 기호)은 각 레벨 별 대표 질문의 하위 질문(또는 꼬리 질문)으로 예약되어 있습니다.
    4. 이외 각 질문 별 답변에서 중요한 키워드나 제목은 볼드(**…**)처리하고 내용을 자유롭게 작성합니다.
    5. 각 내용 별로 구분선(./divide)을 사용해 가독성을 올리고 서식 통일 해주시면 됩니다.

---

# Level 0

## 컴퓨터 구조와 관련하여 CPU, RAM, 저장장치의 역할과 상호작용에 대해 설명하라.

컴퓨터 구조에서 CPU, RAM, 저장장치는 각자의 역할을 수행하며 컴퓨터 동작을 위해 상호작용 한다. 이 컴퓨터 요소의 역할에 대하여 비유를 통해 설명하기 위해 각 요소를 의인화, 사물화 하여 어떠한 작업실(사무실)에 있다고 가정한다.

**CPU**

중앙처리장치(Central Processing Unit, 이하 CPU)는 컴퓨터 시스템을 통제하고 프로그램의 연산을 실행, 처리하는 요소이다.

CPU는 작업실에 위치한 작업자(책상 주인)이다. 이 작업자는 책상에 앉아 어떠한 일을 처리할 수 있다. 그렇게 ‘처리’함으로써 작업실의 사무는 다른 활동으로 이어지거나 하여 운영된다. 작업자는 일 처리를 위해 자신이 사용할 도구(연필, 자, 칼, 가위 등)를 필요로 한다. 이 도구는 작업자가 곧바로 집어들 수 있는 위치에 있는 것이 일 처리의 측면에서 빠르고 편할 것이다. 따라서 작업자는 자신과 가까워 손을 곧장 옮길 수 있는 곳에 도구를 두고 레지스터, 캐시 메모리라는 이름으로 부른다. 작업자가 자주 사용하는 도구는 이곳에 놓여져 있을 확률이 크다.

**RAM**

임의접근메모리(Random Access Memory, 이하 RAM)은 컴퓨터의 전원 공급 및 동작 시작부터 종료까지 어떠한 데이터나 프로세스를 ‘기억’하기 위해 존재하는 요소이다.

RAM은 작업실에 위치한 작업자가 일할 수 있는 책상이다. 이 책상이 넓으면 다양한 물건들을 올려 작업할 수 있고, 반대로 좁다면 상대적으로 적은 물건들을 올려 수시로 정리하면서 작업해야 한다. 작업자가 출근하면 그 날 주어진 업무를 처리하기 위해 평소에 애용하던 도구들을 꺼내오기 시작한다. 만약 연필이 필요해지면 연필을 가져온다. 혹은 칼이 필요해지면 칼을 가져와 책상에 올려 둔다. 일을 처리하는 곳은 책상이므로 도구를 책상에 올려놓아야 일할 수 있다.

**저장장치**

저장장치는 사물함(Cabinet)과 같다. 평소에 사용할 도구들은 저장장치인 사물함에 보관되어 있다. 작업자가 일을 하고있지 않는 시간에는 책상에 각종 도구들을 어지러이 올려 둘 수 없기에 사물함에 보관한다고 생각하자. 그 면적과 부피가 확실히 책상보다는 크고 넓기 때문에 많은 도구들을 보관할 수 있다. 단, 도구를 써야 할 때, 의자에서 일어나 사물함을 열어 도구가 있는지 차례대로 뒤적거려야 하는 번거로움이 있다. 또한 새로운 도구를 가져왔는데 책상에 올려둘 곳이 없다면, 다시 사물함에 도구를 갖다 놓아 정리를 해야한다.

CPU, RAM, 저장장치는 사무실의 업무가 정상적으로 진행되고 회사가 잘 운영되기 위해서 서로 협력한다. 또 운영체제 등의 관리자급 직원에게 관리받는 요소이기도 하다.

---

### 캐시 메모리의 개념과 종류, 역할에 대해 설명하라.

**캐시 메모리**는 CPU가 메인메모리에 접근해서 데이터를 가져와 연산 처리하는데 매우 느리다는 사실을 해소하고자 둘 사이에 추가로 끼운 메모리이다. CPU의 연산 속도에 비해서는 느리지만 메인메모리에 접근하여 데이터를 가져오는 것보다 캐시 메모리에 접근하여 데이터를 가져오는 것이 더 빠르기 때문에 시스템 성능 향상에 도움이 된다. 캐시 메모리는 휘발성 메모리인 RAM의 일종이다. 단, 메인메모리 역시 RAM이지만 그보다 접근 속도가 상대적으로 빠르기에 메인메모리와 구분된다.

자주 사용하는 데이터라면 매번 메인메모리에 접근해 가져오는 것보다 상대적으로 가깝고, 빨라 접근하기 용이한 곳에 저장해두어 사용하는 것이 성능 측면에서 유리할 것이다. 이렇게 자주 사용되는 데이터를 미리 보관해두는 것을 **캐싱**이라고 하며, 이 캐싱 기법을 적용한 메모리가 캐시 메모리인 것이다. 생각해보면 캐싱은 우리 삶에 다양한 형태로 활용되고 있음을 알 수 있는데, 캐시 메모리도 그 중 하나의 예시이고, 네트워크나 다른 분야에서도 이미 적용되어 있다.

**캐시 메모리는 또다시 위치, 속도, 크기, 용도 등에 따라 3~4개의 수준으로 분류할 수 있다.**

- L1 Cache: 레벨1 캐시는 일반적으로 프로세서 자체에 내장되어 있다. 최근에 사용된 명령어나 데이터를 저장한다. 최근에 사용되었다는 것은 다시 불려와 사용될 일이 잦다는 원리에 의거한 것으로, 이는 지역성과 관련이 깊다. 다른 유형의 저장장치에 비해 속도가 매우 빠르다는 특징이 있다.
- L2 Cache: 레벨2 캐시는 레벨1 캐시와 같이 프로세서 자체에 내장되어 있다. 대부분 레벨1 캐시보다 크기가 크지만 속도는 느리다.
- L3 Cache: 레벨3 캐시는 CPU 코어에 내장된 윗 수준 캐시와 달리 전체 프로세스가 접근할 수 있는 공유 메모리 풀 형태로 작동한다. 마찬가지로 윗 수준 캐시보다 크기가 커지고 속도는 느려진다.
- L4 Cache: 레벨4 캐시는 레벨3 캐시 이후로 캐시 메모리를 추가한 형태이다.

캐시 메모리는 자주 접근하는 특정 데이터를 CPU 가까이 보관해두고 메인메모리를 검색하는 것보다 빠르게 이용하게 만듦으로써 그렇게 절약한 대기시간을 다른 작업에 투자해 전체적인 성능 향상을 꾀할 수 있도록 해준다. 단, 캐시 메모리에 원하는 데이터가 없는 상황도 분명히 생긴다. 이를 **캐시 미스**라고 한다. 이런 경우에는 곧바로 메인메모리에 접근해 데이터를 가져오는 것보다, 캐시 메모리를 검색한 뒤 데이터가 없는 것을 확인하고 메인메모리로 이동하는 것이므로 오히려 데이터 검색이 느려지는 효과가 발생하기도 한다. 따라서 캐시 미스 상황을 최대한 줄일 수 있는 방향을 고민해보는 것이 바람직하다.

정리하자면, 캐시 메모리는 대기시간 절약, 프로세스 처리량 증가, 전력 소비 감소, 안정성 향상 등 여러가지 이점을 제공하는 컴퓨팅 자원이다.

---

### CPU 아키텍처의 종류와 특징에 대해 설명하라.

CPU 아키텍처는 CPU가 명령어를 해석하고 실행하는 방식을 정의한다. 가장 널리 알려진 CPU 아키텍처는 x86과 ARM이 있다. 이렇게 CPU 아키텍처의 종류가 나눠지는 이유는, CPU가 해석할 명령어를 나열하고 집합한 형태가 다르기 때문이다. **CISC**(Complex Instruction Set Computing) 방식은 다양하고 복잡한 명령어 집합을 사용하여 한 명령어를 사용해 여러 명령어를 실행할 수 있다. 따라서 활용도는 높지만 실행 속도가 느릴 수 있다. **RISC**(Reduced Instruction Set Computing) 방식은 간단한 명령어 집합을 사용하여 각 명령어를 실행할 수 있다. 따라서 활용 시 명령어 조합이 길어지지만 각 명령어는 단순하고 빠르게 실행된다.

**x86**

x86 아키텍처는 Intel이 개발한 아키텍처이며, 16비트 프로세서로 시작해 32비트(x86), 64비트(x64) 버전으로 확장되었다. 이 아키텍처는 주로 개인용 컴퓨터나 서버, 워크스테이션 등에서 사용된다. CISC 방식의 아키텍처이기에 이 방식이 가진 다양한 명령어 집합은 여러 소프트웨어와 호환할 수 있다. 또한 고성능 컴퓨팅 작업에 사용되기 좋다.

**ARM**

ARM 아키텍처는 ARM 홀딩스에서 개발한 아키텍처로 저전력 소비를 중점으로 설계된 만큼, 주로 스마트폰, 태블릿, 임베디드 시스템 등에서 사용된다. RISC 방식의 아키텍처이기에 단순한 명령어를 사용하며 특히 모바일 장치와 같이 배터리 수명이 중요한 디바이스에 적합하다.

---

### iOS 기기에서 사용되는 AP의 특징과 역할에 대해 설명하라.

**AP**(Application Processor)는 디바이스의 중심적인 역할을 담당하는 핵심 요소이다. 시스템을 구성하는 여러 요소가 하나의 칩에 들어있다고 하여 **SoC**(System on Chip)으로 불리며, CPU, GPU, NPU, DSP 등 다양한 기능을 하나의 칩에 통합한 형태이다. 작게 집적화한 소형 칩인 AP는 그 용도에 맞게 모바일 기기처럼 작은 디바이스에서 사용되며 성능, 전력 소모, 활용성 등 디바이스 설계에 직접적인 영향을 미친다.

애플의 AP는 다양한 종류가 있다. 그 중에서도 iOS 기기에서 사용되는 AP는 A시리즈라고 불리운다. A시리즈 AP는 내장된 CPU, GPU, NPU, 각종 메모리 등의 도움을 받아 iOS 기기의 데이터 처리, 그래픽 처리, 인공지능 및 머신러닝, 통신 등의 역할을 수행한다. ARM 아키텍처로 설계되어 있기에 iOS 기기의 성능을 높이 끌어 올리면서도 배터리 수명을 고려해 저전력 효율화를 꾀한다. 또 지문, 얼굴 인식 등 개인정보 데이터를 안전하게 처리 한다던가, 최상의 사용자 경험을 위해 강력하고 효율적인 기능을 가진 AP로 설계되어 있다.

---

## 운영체제의 역할과 iOS에서의 운영체제 구조에 대해 설명하라.

**운영체제**는 시스템 사이드(하드웨어와 가까운)의 특별한 소프트웨어이다. 운영체제는 다른 사용자 소프트웨어가 하드웨어를 이용해 원활하게 동작하기 위하여 존재하는 중간 관리자이다. 하드웨어 및 시스템 자원을 관리하고, 응용 소프트웨어를 실행하기 위하여 추상화된 하드웨어 인터페이스를 제공한다. 대표적으로 입출력, 메모리 할당과 같은 하드웨어 기능을 제공하고, 멀티태스킹을 지원하는 경우 스케줄링을 비롯한 프로세스 관리 등을 운영체제가 담당한다.

**iOS**는 macOS를 기반으로 만들어져 iPhone과 같은 모바일 장치를 사용하기 위해 필요한 운영체제이다. macOS와 마찬가지로 Darwin Foundation을 기반으로 한다. iOS는 네 개의 추상화 계층으로 구성되어 있다. 운영체제의 구조를 추상화하여 계층 별로 구분 지으면 기기를 이용하거나 애플리케이션을 개발할 때 필요한 기술을 쉽게 접근하여 이용할 수 있다.

**iOS 추상화 구조**

1. **Core OS**
    
    하드웨어와 상호작용하는, 가장 시스템 사이드에 위치한 계층이다. 이 계층은 보안, 통신, 메모리 관리, 파일 시스템 관리 등의 기본적인 기능을 포함한다.
    
    Accelerate, Directory Service, Disk Arbitration, OpenCL, System Configuration
    
2. **Core Service**
    
    Core OS 레이어 위에 위치해 있으며 보다 고수준의 API를 통해 데이터 관리, 네트워킹, 위치 서비스 제공 등의 기능을 제공한다.
    
    Foundation, Address Book, Core Data, Core Foundation, Social, Quick Look, Security, WebKit
    
3. **Media**
    
    Core Service 레이어 위에 위치해 있으며 오디오, 비디오, 그래픽 처리와 같은 멀티미디어 컨텐츠를 처리하는 기능을 제공한다.
    
    AVFoundation, Core Animation, Core Audio, Core Image, Core Text, OpenAL, OpenGL, Quartz
    
4. **Cocoa Touch**
    
    사용자 소프트웨어 밑의 가장 상위에 있는 계층이며 사용자 인터페이스를 구성하고 멀티터치, 제스처 인식, 가속도계, 위치 서비스 등의 기능을 포함한다. UI Component를 관리하고 이벤트 처리를 담당한다. 또한, 애플리케이션의 생명주기 관리, 알림, 네트워킹 등 하위 계층의 기능을 보다 고수준의 API를 통해 이용할 수 있게 한다.
    
    AppKit, UIKit, SwiftUI
    

---

### 프로세스와 스레드의 차이점, iOS에서의 프로세스와 스레드 관리 방법에 대해 설명하라.

**프로세스**는 정적인 코드 덩어리인 ‘프로그램’이 운영체제로부터 자원을 할당받아 동적으로 활성화된 작업의 단위이다. **스레드**는 프로세스가 할당받은 자원을 이용해 동작하는 중 만들어진 동작 흐름의 단위이다.

**메모리 사용과 관련한 프로세스와 스레드의 비교**

- **프로세스**
    
    프로그램 활성화와 작업 수행을 위해 운영체제로부터 할당받는 자원 중, 대표적인 것이 바로 메모리이다. 프로그램 활성화를 통해 프로세스가 탄생한다는 것은 정적인 코드 덩어리가 메모리에 채워지게 된다는 것이고, 이 메모리는 보통 코드, 데이터, 스택, 힙 영역으로 구분되어 용도에 맞게 할당 및 해제된다. 할당받은 메모리 영역은 프로세스 간 독립적(고립적)으로 사용되기 때문에 프로세스 간 자원을 공유하기 위해서는 운영체제의 도움을 받아 IPC(Inter-Process Communication), LPC(Local inter-Process Communication), 메세지 버스, 공유 메모리 사용 방식을 사용해야 한다. 단, 이 경우 단순히 CPU 레지스터 교체 뿐 아니라 RAM과 CPU 간의 캐시 메모리까지 초기화도기 때문에 오버헤드가 크다는 단점이 있다. 따라서 현대 컴퓨터 운영체제에서는 멀티 프로세싱을 지원하고 있지만 멀티 스레딩을 기본적으로 사용한다.
    
- **스레드**
    
    프로세스는 반드시 하나 이상의 스레드를 갖게 되는데 대표되는 하나의 스레드를 메인 스레드라고 부른다. 스레드는 한 프로세스의 동작 흐름에서 파생한 여러 흐름의 단위이기 때문에, 역시 운영체제로부터 얻은 자원을 사용할 수 있다. 여러 스레드 간에는 한 프로세스가 할당받은 자원을 공유하면서 프로세스 실행 흐름의 일부가 되기 때문에 동시 작업도 가능하다. 이때 프로세스에게 주어진 네 가지 메모리 영역 중, 스레드는 스택 영역에 해당하는 메모리만 복사해 독립적으로 유지하고, 나머지 영역은 다른 스레드들과 공유한다. 독립적인 스택 영역을 가지고 있다는 것은 함수 호출 및 복귀가 가능하다는 것이기에 스레드는 독립적인 실행 흐름의 단위로서 존재할 수 있게 된다. 또 다른 메모리 영역에 대해서는 공유하면서 읽고 쓰기가 가능하다. (반면 프로세스는 별도의 통신 수단없이 다른 프로세스의 메모리에 직접 접근할 수 없다. 이 경우 운영체제는 잘못된 메모리 접근으로 인해 Abort 콜을 내릴 것이다.)
    

**동시성 처리와 관련한 프로세스와 스레드의 비교**

- **프로세스**
    
    프로세스가 생성되면 메모리에 해당 프로세스의 PCB(Process Control Block)가 함께 생성되고 종료시 삭제된다. 운영체제는 PCB에 담긴 프로세스의 고유 정보를 통해 프로세스의 생명주기를 관리하고 다른 프로세스와의 동기화를 제어할 수 있다. CPU가 다중 처리를 수행할 때 PCB에 담긴 프로세스의 상태를 확인하고 상태 변경 및 Context Switching 등, 동시성 제어를 수행한다. 프로세스는 운영체제로부터 이러한 제어를 받으며 생성, 준비, 실행, 대기, 종료의 프로세스 상태 전이가 이루어지며 동작한다.
    
- **스레드**
    
    스레드가 생성되면 메모리에 해당 스레드의 TCB(Thread Control Block)이 함께 생성되고 종료 시 삭제된다. 더욱 정확히는 운영체제가 PCB 안에 TCB를 통해 스레드의 고유 정보를 저장하고 생명주기 관리에 활용한다. 프로세스와 마찬가지로 운영체제는 TCB를 통해 스레드의 상태를 확인하고 상태 변경 및 Context Switching 등의 동시성 제어를 수행하는데, TCB는 스택 및 간단한 레지스터 포인터 정보만을 저장하기 때문에 PCB의 Context Switching 보다는 가볍고 빠르다. 스레드는 운영체제로부터 이러한 제어를 받으며 생성, 준비, 대기, 종료의 스레드 상태 전이가 이루어지며 동작한다.
    

iOS는 멀티태스킹 환경을 지원한다. iOS에서 모든 애플리케이션은 각각 별도의 프로세스로 실행된다. iOS는 앱 간에 엄격한 샌드박스 환경을 적용하여 각 앱의 프로세스가 다른 앱의 데이터나 자원에 접근하지 못하게 한다. 프로세스의 경우, 애플리케이션 프로세스의 생명주기는 iOS에서 자동으로 관리되고 처리되며, 개발자는 UIKit이나 SwiftUI와 같은 프레임워크의 생명주기 이벤트를 통해 이를 관찰하고 적절히 반응하면 된다.

스레드의 경우, 태스크 기반 병렬 프로그래밍 지원 프레임워크인 GCD(Grand Central Dispatch)를 이용해 시스템이 스레드를 관리할 수 있도록 개발자가 코드 상에서 명시해 줄 수 있다. 또한 C 기반으로 제작된 GCD를 보다 고수준의 인터페이스로 제공하는 Operation 및 OperationQueue를 이용할 수도 있다.

---

### iOS의 샌드박스(Sandbox) 개념과 역할, 앱 간 데이터 공유 방법에 대해 설명하라.

샌드박스는 

---

# Level 1
